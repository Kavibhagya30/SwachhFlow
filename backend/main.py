from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import List
import json
import os

from . import models, schemas, crud, database
from .services import storage, ai

# Initialize DB tables
models.Base.metadata.create_all(bind=database.engine)

app = FastAPI(title="SwachhFlow Backend")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Allow all for dev
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/")
def read_root():
    return {"message": "SwachhFlow Backend API"}

@app.get("/gvps", response_model=List[schemas.GVPResponse])
def list_gvps(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_gvps(db, skip=skip, limit=limit)

@app.post("/gvps/report", response_model=schemas.GVPResponse)
def report_gvp(gvp: schemas.GVPCreate, db: Session = Depends(get_db)):
    return crud.create_gvp(db, gvp)

@app.post("/gvps/verify")
async def verify_gvp(
    gvp_id: int = Form(...),
    lat: float = Form(...),
    lng: float = Form(...),
    status: str = Form(...), # CLEARED / PARTIALLY
    critical_level: str = Form(None), # HIGH/MEDIUM/LOW
    file: UploadFile = File(...)
):
    # 1. Upload to MinIO
    file_bytes = await file.read()
    image_url = storage.upload_file(file_bytes, file.filename, file.content_type)
    
    if not image_url:
        raise HTTPException(status_code=500, detail="Image upload failed")

    # 2. Check Geo-stamp
    db = database.SessionLocal()
    gvp = crud.get_gvp(db, gvp_id)
    if not gvp:
        db.close()
        raise HTTPException(status_code=404, detail="GVP not found")
    
    dist = ((gvp.latitude - lat)**2 + (gvp.longitude - lng)**2)**0.5
    if dist > 0.001: 
        db.close()
        return {"status": "FAILED", "reason": "Location mismatch", "image_url": image_url}

    # 3. AI Verification (Only if claiming full clearance or for audit)
    # If user says PARTIALLY, we might trust them or still check garbage presence.
    # If user says CLEARED, we check for CLEANNESS.
    
    is_clean_ai = ai.verify_garbage(file_bytes)
    
    # Logic:
    # If Claim=CLEARED and AI=CLEAN -> SUCCESS
    # If Claim=CLEARED and AI=GARBAGE -> FAILURE (False claim)
    # If Claim=PARTIAL -> Accepted (AI check just logs it)
    
    if status == "CLEARED":
        if is_clean_ai:
            crud.update_gvp_status(db, gvp_id, "VERIFIED", None)
            db.close()
            return {"status": "SUCCESS", "reason": "Verified Clean!", "image_url": image_url}
        else:
            db.close()
            return {"status": "FAILED", "reason": "AI detected garbage. Please clean thoroughly.", "image_url": image_url}
    
    elif status == "PARTIALLY":
        crud.update_gvp_status(db, gvp_id, "COLLECTED", critical_level) # using COLLECTED as partial alias or just store PARTIAL
        # User requested "mark status as cleared or partialy cleared"
        # Let's string match DB status.
        crud.update_gvp_status(db, gvp_id, "PARTIALLY_CLEARED", critical_level)
        db.close()
        return {"status": "SUCCESS", "reason": "Partial status recorded", "image_url": image_url}
        
    db.close()
    return {"status": "FAILED", "reason": "Invalid status"}

@app.post("/alerts", response_model=schemas.AlertResponse)
def create_driver_alert(alert: schemas.AlertCreate, db: Session = Depends(get_db)):
    return crud.create_alert(db, alert)

@app.get("/routes/all", response_model=List[schemas.TruckRouteResponse])
def get_all_routes(db: Session = Depends(get_db)):
    routes = db.query(models.TruckRoute).all()
    # route_json is already a dict/list, Pydantic should handle it if defined correctly
    return routes

@app.get("/driver/route/{mobile}")
def get_my_route(mobile: str, db: Session = Depends(get_db)):
    # mobile might need decoding or just raw string
    route = crud.get_driver_route(db, mobile)
    if not route:
        return {"message": "No active route"}
    
    # Transform route_json to friendly format if needed
    # The route stored in DB is JSON.
    return {
        "route_id": route.route_id,
        "points": route.route_json
    }

@app.post("/routes/generate")
def trigger_routing():
    # Trigger the python script logic
    # This might be slow, so ideally async.
    # For now, we will assume routes are pre-generated by seed/cron.
    return {"message": "Please run the routing engine script manually or via seed job for now."}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
